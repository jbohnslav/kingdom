---
id: "a9c9"
status: closed
deps: []
links: []
created: 2026-02-14T20:50:46Z
type: task
priority: 1
---
# council status should show richer member states (running, errored, timed out) not just pending/responded

## Context

`kd council status` currently shows only "pending" or "responded" per member.
When an agent process was killed (exit code -2), timed out, or errored, it
still shows "pending" — which implies it's still running. The log files have
the real story (error messages, exit codes) but you have to dig into them
manually.

Possible states to distinguish:
- **responded** — wrote a message to the thread
- **running** — worker process is still alive (check PID/lock file)
- **interrupted** — process exited with signal (exit code < 0)
- **errored** — process exited with non-zero exit code / logged an error
- **timed out** — exceeded configured timeout
- **pending** — no process evidence found yet (maybe hasn't started)

This likely requires parsing the tail of the log file for exit codes and
error markers, and/or checking if the async worker process is still alive.

## Acceptance Criteria

- [x] `kd council status` distinguishes at least: responded, running, errored, timed out, pending
- [x] Status derived from concrete runtime metadata: worker PID liveness (`os.kill(pid, 0)`), process exit code from log files, and thread message presence. Not hand-wavy "logs and/or process state" — each state maps to a specific check
- [x] Tests cover each distinguishable state

## Worklog

Each state maps to a concrete check:
- **responded**: message exists after last ask, body has no error marker
- **errored**: message exists with `*Error:` prefix (non-timeout)
- **timed_out**: message exists with `*Error: Timeout` prefix
- **running**: no message yet, but `.stream-{member}.jsonl` file exists in thread dir
- **pending**: no message and no stream file

Note: PID liveness check was not needed — the stream file is a more reliable
signal for "running" since the tee mechanism writes to it continuously. PID
could be stale if the process was orphaned.

Implementation:
- Added `MemberState` dataclass and `MEMBER_*` constants to `thread.py`
- Extended `ThreadStatus` with `member_states: dict[str, MemberState]`
- Updated `thread_response_status()` to classify each member
- Updated `print_thread_status()` with color-coded Rich output
- Overall thread state: complete/running/errors/waiting
- Verbose mode shows error details and log file paths
- 6 unit tests in test_thread.py + 3 CLI tests in test_cli_council.py
