---
from: king
to: all
timestamp: 2026-02-15T00:05:41Z
---

Review the design doc below comprehensively. This is a complex multi-phase project and I need you to be thorough. For each phase, consider:

1. **Completeness**: Are there missing requirements or edge cases we haven't thought of?
2. **Feasibility**: Are any requirements technically harder than they appear? What are the hidden complexities?
3. **Dependencies**: Are the phases ordered correctly? Are there cross-cutting concerns that span phases?
4. **Risk**: What could go wrong? What are the most likely failure modes?
5. **Config design**: The group chat config lives in config.json under council.chat. Is this the right shape? What fields are missing?
6. **Streaming architecture**: The TUI polls .stream-{member}.md files. Codex outputs JSONL. What normalization is needed and where should it live?
7. **Thread system**: Will the current thread system (sequential message files, YAML frontmatter) handle group chat well? What about concurrent writes from multiple agents in auto-mode?
8. **Textual as a dependency**: Is this the right choice? What's the complexity of building a chat TUI with it? Any gotchas?
9. **The /mute /unmute feature**: Design doc says no slash commands but also lists /mute and /unmute. Which is it?
10. **Auto-commit (1e3d)**: What exactly should this look like? Git add + commit after every council response? Only after all members respond? User prompt first?

Be specific. Call out contradictions, missing details, and things that will bite us during implementation. Reference specific code paths where relevant (you have access to the codebase).

Here is the design doc:

# Design: council-improvements

## Goal

Make council interactions feel natural and alive. Fix all existing bugs/UX issues with the CLI-based council workflow (the "inside Claude Code" path), then build a dedicated `kd chat` TUI as a sidecar for rich, streaming, multi-agent group chat.

## Context

The council today works but feels dead. You send a message, wait 4 minutes behind a spinner, then get 3 walls of text dumped at once. The `.stream-{member}.md` files already capture live output during execution, but `watch_thread()` ignores them entirely — it only polls for finalized message files. The async error handling is brittle (silent `Error: None`, no retry, `reset` nukes everything). Status reporting is binary (pending/responded) when reality has more states (running, errored, timed out, interrupted).

Beyond CLI fixes, we want a `kd chat` TUI that runs in a separate terminal pane alongside Claude Code. It should feel like a Slack thread with three engineers: you send a message, see responses stream in with color-coded panels, and optionally let the councillors discuss amongst themselves with bounded auto-turns.

The thread/messaging system we built since the last TUI attempt is the key enabler — the TUI becomes a pure view+input layer over thread files, not a stateful monolith.

## Requirements

### Phase 1: Fix existing council CLI
- **Async error handling** (6412): Meaningful error messages, automatic retry (at least once), per-member session reset (`kd council reset --member <name>`), `kd council retry <thread-id>` for re-querying failed members
- **Richer status** (a9c9): Distinguish at least: responded, running, errored, timed out, pending — derived from process state and log files
- **Configurable members** (549b): `kd council ask` respects `config.json` council.members list; users can include/exclude agents without code changes
- **`council show` pagination** (70f6): Default to latest turn (last king message + responses), add `--last N` and `--all` flags, show hidden message count
- **Visual turn separation** (d09d): Clear visual separators between conversational turns in `council show`
- **`council list` enrichment** (a4f5): Show per-member response status and topic/first-line summary per thread
- **Auto-commit threads** (1e3d): After council responses complete, prompt or auto-commit thread files
- **Rename `_print_thread_status`** (41fb): Rename to `display_thread_status` to match project style

### Phase 2: `kd chat` TUI
- Dedicated terminal app (Textual or Rich Live + prompt_toolkit)
- Runs in a separate pane alongside Claude Code — not inside it
- Opens existing thread or creates new one
- User types at bottom, messages broadcast to all council members
- Responses stream into color-coded panels as `.stream-{member}.md` files update
- All state persists to standard thread files (crash-safe, `kd council show` compatible)
- `@member` addressing for directed messages
- `/mute` and `/unmute` per member

### Phase 3: Group chat mode
- After initial broadcast round, councillors enter auto-mode
- Each councillor gets full thread context and responds to the discussion
- Round-robin turn order (simplest, sufficient for 3 members)
- All group chat behavior configured in `config.json` under `council.chat`:
  - `auto_rounds`: max rounds without user input (default 3)
  - `mode`: "broadcast" (parallel first round, then auto-turns) or "sequential" (round-robin from the start)
- User typing interrupts auto-mode immediately
- Stop conditions: max rounds reached, or all members produce short/empty responses
- TUI input commands are minimal:
  - `@member` — direct message to one councillor
  - `` — broadcast to all (default if no @-mention)
  - No slash commands for config — configure via `config.json`, not the TUI

## Non-Goals
- No TUI inside Claude Code's terminal — accept the separate pane
- No tmux-as-transport — tmux is just a viewport convenience
- No complex activation strategies (natural order, talkativeness scoring) — round-robin is enough
- No anonymization for now (Karpathy-style) — we know which model is which and that's fine
- No token/cost budgeting per round — keep it simple, just cap turn count
- No slash commands or runtime config in the TUI — all behavior configured via `config.json`
- No `kd council review` in this PR (1c4b) — that's a separate feature on top
- No research spike (520a) — council responses already informed the design

## Decisions

- **Textual over Rich Live**: Textual gives us scrollable panels, proper input widget, layout management, and async-native architecture. Rich Live + prompt_toolkit would be lighter but we'd reinvent half of Textual. Kingdom already depends on Rich; Textual is a natural step up.
- **File polling over events**: Poll `.stream-*` and message files at 250ms. LLM responses take seconds; sub-100ms latency doesn't matter. No need for watchdog/inotify complexity.
- **Thread files as single source of truth**: The TUI reads/writes the same thread directory as `kd council show/ask`. No separate state. If the TUI crashes, restart and it reconstructs.
- **Group chat is round-robin with hard cap**: No heuristic "conflict detection" or mention-based routing. Just: each member responds once per round, up to N rounds, user can interrupt. Simple and predictable.
- **Codex stream normalization**: Codex outputs JSONL events, not plain prose. The streaming display layer must parse/normalize per-backend before rendering. Reuse the existing `parse_codex_response()` logic.
- **`kd chat` is the command name**: Not `kd council chat`. It's a top-level command because it's a primary interaction mode, not a council subcommand.
- **Config-driven, not command-driven**: Group chat behavior (auto-rounds, mode) lives in `config.json`, not TUI slash commands. The TUI input is just for talking: plain text goes to all, `@member` goes to one.

## Open Questions
- (none currently)

---

## Council Thread: council-f30b

(Council responses preserved below for reference — see thread files for full text.)
