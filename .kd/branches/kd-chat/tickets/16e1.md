---
id: "16e1"
status: closed
deps: [7ddd]
links: []
created: 2026-02-15T19:46:08Z
type: task
priority: 1
---
# User input and query dispatch

## Context

Handle user input: Enter sends, Shift+Enter newlines, @member addressing. On send, write king message to thread files, then launch `member.query()` via `asyncio.to_thread()`. Uses `Council.create()` directly — no CLI shelling.

## Acceptance Criteria

- [ ] **Enter** sends the message; **Shift+Enter** inserts newline
- [ ] Input area grows with content up to a reasonable max height
- [ ] Plain text broadcasts to all council members (creates WaitingPanels for all)
- [ ] `@member` sends only to named member; `@all` explicit broadcast
- [ ] King message written to thread files via `add_message()` before querying
- [ ] Member queries launched via `asyncio.to_thread(member.query, ...)` — one per targeted member, in parallel for broadcast
- [ ] Agent availability errors (FileNotFoundError) render as ErrorPanels

## Worklog

- 2026-02-15: Reopened after council review (council-4a36). Multiple findings:
  - **Critical: `run_query()` never writes responses to thread files.** After `member.query()` returns, the response is never passed to `add_message()`. Compare with `council_ask()` in cli.py and `query_to_thread()` which both persist responses. Consequence: responses don't survive TUI restart, `kd council show` won't display them, and the poller never sees a finalized message file so panels stay in Waiting/Streaming state forever. (All three members found this independently.)
  - **Stream file not cleaned up after query.** `query_to_thread()` deletes `.stream-{member}.jsonl` after writing the finalized message. `run_query()` doesn't. Stale stream files linger and confuse the poller on subsequent queries. (cursor + claude)
  - **Partial timeout responses lost.** When `response.error` AND `response.text` (agent produced output before timing out), the error path only fires when `not response.text`, so partial responses are silently dropped. Second consequence of missing `add_message()`. (claude)
  - **King message not rendered immediately.** `send_message()` writes the king message to thread files and mounts WaitingPanels, but never mounts a MessagePanel for the king's own message. It only appears on the next 100ms poll cycle, causing a brief visual glitch where WaitingPanels appear with no king message above them. (claude)
  - **`asyncio.get_event_loop()` deprecated since Python 3.10.** Works inside Textual because it manages the loop, but fragile. Should use `self.run_worker()` or Textual's worker API since `send_message()` is called from sync `on_key()`. (claude)
- 2026-02-15: Fixed all 5 findings:
  - `run_query()` now always calls `add_message(..., body=response.thread_body())` — matches `query_to_thread()` pattern. Handles success, error-only, and partial timeout via `thread_body()`.
  - `run_query()` now deletes stream file in `finally` block.
  - Removed all widget manipulation from `run_query()` — the poll-driven `handle_new_message()` already handles WaitingPanel→MessagePanel/ErrorPanel transitions. This is simpler and avoids duplicated widget logic.
  - `send_message()` now mounts a king MessagePanel immediately before WaitingPanels, and bumps `poller.last_sequence` to avoid duplicate.
  - Replaced `asyncio.get_event_loop().create_task()` with `self.run_worker()` (Textual's worker API).
  - 4 new tests: persist success, persist error, persist partial timeout, stream file cleanup. All pass.
